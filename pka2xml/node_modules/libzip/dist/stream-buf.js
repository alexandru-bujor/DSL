"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const data_type_1 = require("./data-type");
class StreamBuffer {
    constructor(buf = Buffer.from('')) {
        this.buf = buf;
        this.fd = 0;
    }
    get Fd() {
        return this.fd;
    }
    set Fd(fd) {
        this.fd = fd;
    }
    get Length() {
        return this.buf.length;
    }
    __size_check(size) {
        if (this.fd + size >= this.buf.length) {
            const buf = Buffer.alloc(this.fd + size);
            this.buf.copy(buf, 0, 0, this.buf.length);
            this.buf = buf;
        }
    }
    ReadUint8() {
        let ret = 0;
        ret = this.buf.readUInt8(this.fd);
        this.fd += data_type_1.SIZE.UINT8;
        return ret;
    }
    WriteUint8(val) {
        this.__size_check(data_type_1.SIZE.UINT8);
        this.buf.writeUInt8(val, this.fd);
        this.fd += data_type_1.SIZE.UINT8;
    }
    ReadUint16(use_be = false) {
        let ret = 0;
        if (use_be) {
            ret = this.buf.readUInt16BE(this.fd);
        }
        else {
            ret = this.buf.readUInt16LE(this.fd);
        }
        this.fd += data_type_1.SIZE.UINT16;
        return ret;
    }
    WriteUint16(val, use_be = false) {
        this.__size_check(data_type_1.SIZE.UINT16);
        if (use_be) {
            this.buf.writeUInt16BE(val, this.fd);
        }
        else {
            this.buf.writeUInt16LE(val, this.fd);
        }
        this.fd += data_type_1.SIZE.UINT16;
    }
    ReadUint32(use_be = false) {
        let ret = 0;
        if (use_be) {
            ret = this.buf.readUInt32BE(this.fd);
        }
        else {
            ret = this.buf.readUInt32LE(this.fd);
        }
        this.fd += data_type_1.SIZE.UINT32;
        return ret;
    }
    WriteUint32(val, use_be = false) {
        this.__size_check(data_type_1.SIZE.UINT32);
        if (use_be) {
            this.buf.writeUInt32BE(val, this.fd);
        }
        else {
            this.buf.writeUInt32LE(val, this.fd);
        }
        this.fd += data_type_1.SIZE.UINT32;
    }
    ReadString(len) {
        const b_ = this.buf.subarray(this.fd, this.fd + len);
        let ret = '';
        ret = b_.toString();
        this.fd += len;
        return ret;
    }
    WriteString(val, encoding) {
        this.__size_check(val.length);
        this.buf.write(val, this.fd, encoding);
        this.fd += val.length;
    }
    ReadBuffer(len) {
        const ret = this.buf.subarray(this.fd, this.fd + len);
        this.fd += len;
        return ret;
    }
    WriteBuffer(val) {
        this.__size_check(val.length);
        for (const v of val) {
            this.buf[this.fd] = v;
            this.fd++;
        }
    }
    ReadBufferNew(len) {
        const b_ = this.buf.subarray(this.fd, this.fd + len);
        const ret = Buffer.from(b_);
        this.fd += len;
        return ret;
    }
    ReadBufferEnd(fd = this.fd) {
        const ret = this.buf.subarray(fd, this.buf.length);
        this.fd = this.buf.length;
        return ret;
    }
}
exports.default = StreamBuffer;
//# sourceMappingURL=stream-buf.js.map