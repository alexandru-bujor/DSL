"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crc32_1 = __importDefault(require("./crc32"));
const crypto_1 = __importDefault(require("crypto"));
const _uint8 = n => n & 0xFF;
const _uint32 = n => n & 0xFFFFFFFF;
class CryptoChiper {
    constructor(key) {
        this.key = Buffer.from(key);
        this.key0 = 0x12345678;
        this.key1 = 0x23456789;
        this.key2 = 0x34567890;
        for (const b of this.key) {
            this.updateKeys(b);
        }
    }
    updateKeys(b) {
        this.key0 = crc32_1.default(this.key0, b);
        this.key1 = _uint32(this.key1 + (this.key0 & 0xFF));
        this.key1 = _uint32(Math.imul(this.key1, 134775813) + 1);
        this.key2 = crc32_1.default(this.key2, this.key1 >>> 24);
    }
    streamByte() {
        const tmp = this.key2 | 2;
        return _uint8(Math.imul(tmp, (tmp ^ 1)) >>> 8);
    }
    encryptByte(b) {
        const encb = this.streamByte() ^ b;
        this.updateKeys(b);
        return encb;
    }
    decryptByte(b) {
        const decb = this.streamByte() ^ b;
        this.updateKeys(decb);
        return decb;
    }
    encrypt(data) {
        const encData = Buffer.alloc(Buffer.byteLength(data));
        let offset = 0;
        for (const b of data) {
            encData.writeUInt8(this.encryptByte(b), offset++);
        }
        return encData;
    }
    decrypt(data) {
        const decData = Buffer.alloc(Buffer.byteLength(data));
        let offset = 0;
        for (const b of data) {
            decData.writeUInt8(this.decryptByte(b), offset++);
        }
        return decData;
    }
}
const HEADER_LENGTH = 12;
class ZIP20 {
    static Encrypt(buf, key, crc) {
        const chiper = new CryptoChiper(key);
        let header = crypto_1.default.randomBytes(HEADER_LENGTH);
        header.writeUInt16LE(crc >> 15, HEADER_LENGTH - 2);
        header = chiper.encrypt(header);
        const data = chiper.encrypt(buf);
        return Buffer.concat([header, data]);
    }
    static Decrypt(buf, key) {
        const chiper = new CryptoChiper(key);
        const decData = chiper.decrypt(buf);
        return decData.slice(HEADER_LENGTH);
    }
}
exports.default = ZIP20;
//# sourceMappingURL=std-zip20-enc.js.map