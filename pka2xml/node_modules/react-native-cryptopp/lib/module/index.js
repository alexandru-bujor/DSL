import { NativeModules, Platform } from 'react-native';
import { AES_BLOCK_CIPHERS, HASHES } from './constants';
const cppinstall = NativeModules.Cryptopp;

if (cppinstall && typeof cppinstall.install === 'function') {
  cppinstall.install();
}

const CryptoppModuleCPP = global.cryptoppModule;

if (!CryptoppModuleCPP) {
  const LINKING_ERROR = `The package 'react-native-cryptopp' doesn't seem to be linked. Make sure: \n\n` + Platform.select({
    ios: "- You have run 'pod install'\n",
    default: ''
  }) + '- You rebuilt the app after installing the package\n' + '- You are not using Expo managed workflow\n';
  throw new Error(LINKING_ERROR);
}

const exec = CryptoppModuleCPP.exec;
const execAsync = CryptoppModuleCPP.exec_async;
const CryptoppModule = {
  async: {}
}; // // Add aes candicates

AES_BLOCK_CIPHERS.forEach(cipherName => {
  const encryptName = `${cipherName}_encrypt`;
  const decryptName = `${cipherName}_decrypt`;
  CryptoppModule[cipherName] = {
    encrypt: function () {
      for (var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++) {
        p[_key] = arguments[_key];
      }

      return exec(encryptName, ...p);
    },
    decrypt: function () {
      for (var _len2 = arguments.length, p = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        p[_key2] = arguments[_key2];
      }

      return exec(decryptName, ...p);
    }
  };
  CryptoppModule.async[cipherName] = {
    encrypt: function () {
      for (var _len3 = arguments.length, p = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        p[_key3] = arguments[_key3];
      }

      return execAsync(encryptName, ...p);
    },
    decrypt: function () {
      for (var _len4 = arguments.length, p = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        p[_key4] = arguments[_key4];
      }

      return execAsync(decryptName, ...p);
    }
  };
}); // Add hashes

CryptoppModule.hash = {
  create: CryptoppModuleCPP.createHash // Hash HostObject

};
CryptoppModule.async.hash = {};
HASHES.forEach(hashName => {
  CryptoppModule.hash[hashName] = function () {
    for (var _len5 = arguments.length, p = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      p[_key5] = arguments[_key5];
    }

    return exec('hash', hashName, ...p);
  };

  CryptoppModule.async.hash[hashName] = function () {
    for (var _len6 = arguments.length, p = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      p[_key6] = arguments[_key6];
    }

    return execAsync('hash', hashName, ...p);
  };
}); // // Insecure

CryptoppModule.insecure = {
  md2: function () {
    for (var _len7 = arguments.length, p = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      p[_key7] = arguments[_key7];
    }

    return exec('insecure_md2', ...p);
  },
  md4: function () {
    for (var _len8 = arguments.length, p = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      p[_key8] = arguments[_key8];
    }

    return exec('insecure_md4', ...p);
  },
  md5: function () {
    for (var _len9 = arguments.length, p = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      p[_key9] = arguments[_key9];
    }

    return exec('insecure_md5', ...p);
  }
};
CryptoppModule.async.insecure = {
  md2: function () {
    for (var _len10 = arguments.length, p = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      p[_key10] = arguments[_key10];
    }

    return execAsync('insecure_md2', ...p);
  },
  md4: function () {
    for (var _len11 = arguments.length, p = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      p[_key11] = arguments[_key11];
    }

    return execAsync('insecure_md4', ...p);
  },
  md5: function () {
    for (var _len12 = arguments.length, p = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      p[_key12] = arguments[_key12];
    }

    return execAsync('insecure_md5', ...p);
  }
}; // CMAC

CryptoppModule.CMAC = {
  generate: function () {
    for (var _len13 = arguments.length, p = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      p[_key13] = arguments[_key13];
    }

    return exec('CMAC_generate', ...p);
  },
  verify: function () {
    for (var _len14 = arguments.length, p = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      p[_key14] = arguments[_key14];
    }

    return exec('CMAC_verify', ...p);
  }
};
CryptoppModule.async.CMAC = {
  generate: function () {
    for (var _len15 = arguments.length, p = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
      p[_key15] = arguments[_key15];
    }

    return execAsync('CMAC_generate', ...p);
  },
  verify: function () {
    for (var _len16 = arguments.length, p = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
      p[_key16] = arguments[_key16];
    }

    return execAsync('CMAC_verify', ...p);
  }
}; // HMAC

CryptoppModule.HMAC = {
  generate: function () {
    for (var _len17 = arguments.length, p = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
      p[_key17] = arguments[_key17];
    }

    return exec('HMAC_generate', ...p);
  },
  verify: function () {
    for (var _len18 = arguments.length, p = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
      p[_key18] = arguments[_key18];
    }

    return exec('HMAC_verify', ...p);
  }
};
CryptoppModule.async.HMAC = {
  generate: function () {
    for (var _len19 = arguments.length, p = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
      p[_key19] = arguments[_key19];
    }

    return execAsync('HMAC_generate', ...p);
  },
  verify: function () {
    for (var _len20 = arguments.length, p = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
      p[_key20] = arguments[_key20];
    }

    return execAsync('HMAC_verify', ...p);
  }
}; // // Utils

CryptoppModule.utils = {
  toBase64: function () {
    for (var _len21 = arguments.length, p = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
      p[_key21] = arguments[_key21];
    }

    return exec('utils_toBase64', ...p);
  },
  toBase64Url: function () {
    for (var _len22 = arguments.length, p = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
      p[_key22] = arguments[_key22];
    }

    return exec('utils_toBase64Url', ...p);
  },
  toHex: function () {
    for (var _len23 = arguments.length, p = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
      p[_key23] = arguments[_key23];
    }

    return exec('utils_toHex', ...p);
  },
  toUtf8: function () {
    for (var _len24 = arguments.length, p = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
      p[_key24] = arguments[_key24];
    }

    return exec('utils_toUtf8', ...p);
  },
  randomBytes: function () {
    for (var _len25 = arguments.length, p = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
      p[_key25] = arguments[_key25];
    }

    return exec('utils_randomBytes', ...p);
  },
  stringToBytes: function () {
    for (var _len26 = arguments.length, p = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
      p[_key26] = arguments[_key26];
    }

    return exec('utils_stringToBytes', ...p);
  }
};
CryptoppModule.async.utils = {
  toBase64: function () {
    for (var _len27 = arguments.length, p = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
      p[_key27] = arguments[_key27];
    }

    return execAsync('utils_toBase64', ...p);
  },
  toBase64Url: function () {
    for (var _len28 = arguments.length, p = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
      p[_key28] = arguments[_key28];
    }

    return execAsync('utils_toBase64Url', ...p);
  },
  toHex: function () {
    for (var _len29 = arguments.length, p = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
      p[_key29] = arguments[_key29];
    }

    return execAsync('utils_toHex', ...p);
  },
  toUtf8: function () {
    for (var _len30 = arguments.length, p = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
      p[_key30] = arguments[_key30];
    }

    return execAsync('utils_toUtf8', ...p);
  },
  randomBytes: function () {
    for (var _len31 = arguments.length, p = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
      p[_key31] = arguments[_key31];
    }

    return execAsync('utils_randomBytes', ...p);
  },
  stringToBytes: function () {
    for (var _len32 = arguments.length, p = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
      p[_key32] = arguments[_key32];
    }

    return execAsync('utils_stringToBytes', ...p);
  }
}; // // Key Derivation

CryptoppModule.keyDerivation = {
  HKDF: function () {
    for (var _len33 = arguments.length, p = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
      p[_key33] = arguments[_key33];
    }

    return exec('key_derivation_HKDF', ...p);
  },
  PKCS12_PBKDF: function () {
    for (var _len34 = arguments.length, p = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
      p[_key34] = arguments[_key34];
    }

    return exec('key_derivation_PKCS12_PBKDF', ...p);
  },
  PKCS5_PBKDF1: function () {
    for (var _len35 = arguments.length, p = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
      p[_key35] = arguments[_key35];
    }

    return exec('key_derivation_PKCS5_PBKDF1', ...p);
  },
  PKCS5_PBKDF2: function () {
    for (var _len36 = arguments.length, p = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
      p[_key36] = arguments[_key36];
    }

    return exec('key_derivation_PKCS5_PBKDF2', ...p);
  },
  Scrypt: function () {
    for (var _len37 = arguments.length, p = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
      p[_key37] = arguments[_key37];
    }

    return exec('key_derivation_Scrypt', ...p);
  }
};
CryptoppModule.async.keyDerivation = {
  HKDF: function () {
    for (var _len38 = arguments.length, p = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
      p[_key38] = arguments[_key38];
    }

    return execAsync('key_derivation_HKDF', ...p);
  },
  PKCS12_PBKDF: function () {
    for (var _len39 = arguments.length, p = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
      p[_key39] = arguments[_key39];
    }

    return execAsync('key_derivation_PKCS12_PBKDF', ...p);
  },
  PKCS5_PBKDF1: function () {
    for (var _len40 = arguments.length, p = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
      p[_key40] = arguments[_key40];
    }

    return execAsync('key_derivation_PKCS5_PBKDF1', ...p);
  },
  PKCS5_PBKDF2: function () {
    for (var _len41 = arguments.length, p = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
      p[_key41] = arguments[_key41];
    }

    return execAsync('key_derivation_PKCS5_PBKDF2', ...p);
  },
  Scrypt: function () {
    for (var _len42 = arguments.length, p = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
      p[_key42] = arguments[_key42];
    }

    return execAsync('key_derivation_Scrypt', ...p);
  }
}; // // Public-key

CryptoppModule.RSA = {
  generateKeyPair: function () {
    for (var _len43 = arguments.length, p = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
      p[_key43] = arguments[_key43];
    }

    return exec('rsa_generateKeyPair', ...p);
  },
  encrypt: function () {
    for (var _len44 = arguments.length, p = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
      p[_key44] = arguments[_key44];
    }

    return exec('rsa_encrypt', ...p);
  },
  decrypt: function () {
    for (var _len45 = arguments.length, p = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
      p[_key45] = arguments[_key45];
    }

    return exec('rsa_decrypt', ...p);
  },
  sign: function () {
    for (var _len46 = arguments.length, p = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
      p[_key46] = arguments[_key46];
    }

    return exec('rsa_sign', ...p);
  },
  verify: function () {
    for (var _len47 = arguments.length, p = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
      p[_key47] = arguments[_key47];
    }

    return exec('rsa_verify', ...p);
  },
  recover: function () {
    for (var _len48 = arguments.length, p = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
      p[_key48] = arguments[_key48];
    }

    return exec('rsa_recover', ...p);
  }
};
CryptoppModule.async.RSA = {
  generateKeyPair: function () {
    for (var _len49 = arguments.length, p = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
      p[_key49] = arguments[_key49];
    }

    return execAsync('rsa_generateKeyPair', ...p);
  },
  encrypt: function () {
    for (var _len50 = arguments.length, p = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
      p[_key50] = arguments[_key50];
    }

    return execAsync('rsa_encrypt', ...p);
  },
  decrypt: function () {
    for (var _len51 = arguments.length, p = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
      p[_key51] = arguments[_key51];
    }

    return execAsync('rsa_decrypt', ...p);
  },
  sign: function () {
    for (var _len52 = arguments.length, p = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
      p[_key52] = arguments[_key52];
    }

    return execAsync('rsa_sign', ...p);
  },
  verify: function () {
    for (var _len53 = arguments.length, p = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
      p[_key53] = arguments[_key53];
    }

    return execAsync('rsa_verify', ...p);
  },
  recover: function () {
    for (var _len54 = arguments.length, p = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
      p[_key54] = arguments[_key54];
    }

    return execAsync('rsa_recover', ...p);
  }
};
export default CryptoppModule;
export * from './types';
//# sourceMappingURL=index.js.map